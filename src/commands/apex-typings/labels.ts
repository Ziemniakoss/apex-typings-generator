import { SfdxCommand, flags } from "@salesforce/command";
import { Messages } from "@salesforce/core";
import { readdir, readFile, writeFile } from "fs/promises";
import { lstatSync } from "fs";
import { join } from "path";
import { parseStringPromise } from "xml2js";

const LABELS_FILE_EXTENSION = ".labels-meta.xml";
interface CustomLabel {
	name: string;
	categories: string[];
	description: string;
}

Messages.importMessagesDirectory(__dirname);
const messages = Messages.loadMessages("sfdx-apex-typings-generator", "labels");
export default class GenerateLabelsTypings extends SfdxCommand {
	public static description = messages.getMessage("description");

	protected static requiresProject = true;
	public static flagsConfig = {
		out: flags.string({
			description: messages.getMessage("flag:out"),
			char: "o",
		}),
	};

	public async run(): Promise<unknown> {
		const customLabels = await this.listFilesWithLabels()
			.then((files) => Promise.all(files.map(this.collectLabelsFromFile)))
			.then((labels) => labels.flat())
			.then(this.collectUniqueLabels);
		const labelsApexClass = this.generateApexClassForLabels(customLabels);
		if (this.flags.out != null) {
			await writeFile(this.flags.out, labelsApexClass);
		} else {
			this.ux.log(labelsApexClass);
		}
		return labelsApexClass;
	}

	private generateApexClassForLabels(customLabels: CustomLabel[]): string {
		let classContent =
			"/*\nGenerated by sfdx-apex-typings-generator\n*/\nglobal class Label{\n";
		for (const label of customLabels) {
			let labelDescription = "/*\n# " + label.name + "\n\n";
			if (label.description != null) {
				labelDescription += label.description + "\n\n";
			}
			if (label.categories.length > 0) {
				labelDescription += "## Categories\n\n";
				for (const category of label.categories) {
					labelDescription += "- " + category + "\n";
				}
				labelDescription += "\n";
			}
			classContent +=
				labelDescription +
				"*/\nglobal static String " +
				label.name +
				";\n";
		}

		return classContent + "}\n";
	}

	private collectUniqueLabels(customLabels: CustomLabel[]): CustomLabel[] {
		const uniqueLabels = [];
		const foundFullNames = new Set();
		for (const customLabel of customLabels) {
			const nameInLowerCase = customLabel.name.toLowerCase();
			if (!foundFullNames.has(nameInLowerCase)) {
				foundFullNames.add(nameInLowerCase);
				uniqueLabels.push(customLabel);
			}
		}
		return uniqueLabels;
	}

	private async collectLabelsFromFile(
		fileName: string
	): Promise<CustomLabel[]> {
		return readFile(fileName, "utf-8")
			.then(parseStringPromise)
			.then((parsedLabels) => {
				// @ts-ignore
				const rawLabels = parsedLabels.CustomLabels?.labels ?? [];
				const labels: CustomLabel[] = [];
				for (const rawLabel of rawLabels) {
					if (rawLabel.fullName == null) {
						console.log("end");
						continue;
					}
					let categories = [];
					if (rawLabel.categories != null) {
						categories = rawLabel.categories[0]
							.split(",")
							.map((rawCategory) => rawCategory.trim());
					}
					labels.push({
						name: rawLabel.fullName[0],
						description:
							rawLabel.shortDescription != null
								? rawLabel.shortDescription[0]
								: null,
						categories,
					});
				}
				return labels;
			});
	}

	private async listFilesWithLabels(baseDir?: string): Promise<string[]> {
		if (baseDir == null) {
			baseDir = this.project.getPath();
		}
		const filesOrDirs = await readdir(baseDir).then((fileOrDirNames) =>
			fileOrDirNames.map((fileOrDirName) => join(baseDir, fileOrDirName))
		);

		const dirs = filesOrDirs.filter((fileOrDir) =>
			lstatSync(fileOrDir).isDirectory()
		);
		const labelsFilesInSubdirs = await Promise.all(
			dirs.map((dir) => this.listFilesWithLabels(dir))
		).then((labels) => labels.flat());
		const filesWithLabels = filesOrDirs.filter(
			(filesOrDirs) =>
				lstatSync(filesOrDirs).isFile() &&
				filesOrDirs.endsWith(LABELS_FILE_EXTENSION)
		);
		return [...filesWithLabels, ...labelsFilesInSubdirs];
	}
}
